# -*- coding: utf-8 -*-

"""
/***************************************************************************
 LandChangeDetector
                                 A QGIS plugin
 detect land use/cover change.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-06-22
        copyright            : (C) 2025 by ayakari
        email                : ayakari1126@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'ayakari'
__date__ = '2025-06-22'
__copyright__ = '(C) 2025 by ayakari'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from PyQt5.QtCore import QByteArray
from fontTools.unicodedata import block
from qgis.PyQt.QtCore import QCoreApplication
from qgis.core import (QgsProcessing,
                       QgsFeatureSink,
                       QgsProcessingAlgorithm,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterRasterLayer,
                       QgsProcessingParameterFileDestination,
                       QgsProcessingParameterFeatureSink,
                       QgsProcessingException,
                       QgsRasterLayer,
                       QgsRasterDataProvider,
                       QgsRasterBlock
                        )
import numpy as np
from numpy import ndarray
import csv

class DetectingRaster(QgsProcessingAlgorithm):
    DATA_TYPE_MAPPING={
        1:np.uint8,
        2:np.uint16,
        3:np.int16,
        4:np.uint32,
        5:np.int32,
        6:np.float32,
        7:np.float64
    }

    INPUT_RASTER_1='INPUT_RASTER_1'
    INPUT_RASTER_2='INPUT_RASTER_2'
    OUTPUT_TABLE='OUTPUT_TABLE'

    def initAlgorithm(self, config):
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                self.INPUT_RASTER_1,
                self.tr('Input raster 1'),
                [QgsProcessing.TypeRaster]
            )
        )
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                self.INPUT_RASTER_2,
                self.tr('Input raster 2'),
                [QgsProcessing.TypeRaster]
            )
        )

        self.addParameter(
            QgsProcessingParameterFileDestination(
                self.OUTPUT_TABLE,
                self.tr('Output table')
                # fileFilter='CSV files (*.csv)'
            )
        )

    def getUniqueValues(self,raster_layer: QgsRasterLayer, band: int = 1) -> ndarray:
        provider: QgsRasterDataProvider = raster_layer.dataProvider()
        block:QgsRasterBlock = provider.block(band,raster_layer.extent(),raster_layer.width(),raster_layer.height())
        nodata=provider.sourceNoDataValue(band)

        array = np.frombuffer(block.data(),dtype=self.DATA_TYPE_MAPPING[block.dataType()])
        array = np.unique(array)
        array = array[array!=nodata]

        return array

    def processAlgorithm(self, parameters, context, feedback):
        raster_layer1:QgsRasterLayer = self.parameterAsRasterLayer(parameters, self.INPUT_RASTER_1, context)
        raster_layer2:QgsRasterLayer = self.parameterAsRasterLayer(parameters, self.INPUT_RASTER_2, context)
        output_table = self.parameterAsFileOutput(parameters, self.OUTPUT_TABLE, context)

        if not raster_layer1 or not raster_layer2:
            raise QgsProcessingException(self.tr("Can't read input raster."))

        provider_1:QgsRasterDataProvider=raster_layer1.dataProvider()
        provider_2:QgsRasterDataProvider=raster_layer2.dataProvider()
        nodata_1 = provider_1.sourceNoDataValue(1)
        nodata_2 = provider_2.sourceNoDataValue(1)

        extent = raster_layer1.extent()
        width = raster_layer1.width()
        height = raster_layer1.height()
        feedback.pushInfo("extent: {}, width: {}, height: {}".format(extent, width, height))

        block1:QgsRasterBlock = provider_1.block(1,extent,width,height)
        block2:QgsRasterBlock = provider_2.block(1,extent,width,height)

        unique_values_1:ndarray=self.getUniqueValues(raster_layer1)
        unique_values_2:ndarray=self.getUniqueValues(raster_layer2)
        unique_values=np.unique(np.concatenate([unique_values_1,unique_values_2],axis=0))
        unique_values_num=len(unique_values)

        transition_matrix = np.zeros(shape=(unique_values_num,unique_values_num))
        for row in range(height):
            for col in range(width):
                value_1=block1.value(row,col)
                value_2=block2.value(row,col)
                if value_1 == nodata_1 or value_2 == nodata_2:
                    continue
                index_1=np.where(unique_values==value_1)[0][0]
                index_2=np.where(unique_values==value_2)[0][0]
                transition_matrix[index_1,index_2]+=1


        with open(output_table, 'w') as f:
            writer = csv.writer(f)
            writer.writerow(list(map(str,unique_values)))
            writer.writerows(transition_matrix)
            # for row in range(unique_values_num):
            #     writer.writerow(transition_matrix[row])
        feedback.pushInfo('table save to: {}'.format(output_table))

        return {self.OUTPUT_TABLE: output_table}


    def name(self):
        return 'Detecting raster'

    def displayName(self):
        return self.tr(self.name())

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return DetectingRaster()
